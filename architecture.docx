# Architecture of the AIVIN MCP Server

## Overview

The AIVIN MCP Server is a Model Context Protocol (MCP) server built with TypeScript, designed to provide tools for reading and processing DOCX documents. It uses Express.js as the web framework and supports multiple transport mechanisms for communication.

## Architecture Components

### 1. Server Setup (src/server.ts)

- **Framework**: Express.js for handling HTTP requests.
- **MCP Integration**: Uses @modelcontextprotocol/sdk/server/mcp.js to create an MCP server instance.
- **Transports**:
  - StreamableHTTP: For bidirectional communication over HTTP POST to `/mcp` endpoint.
- **Configuration**: Loaded from environment variables via dotenv.

### 2. Configuration (src/config/index.ts)

- Manages server settings like name, version, private key, token secrets, etc.
- Uses environment variables with defaults.

### 3. Tools Registration (src/tools/index.ts)

- Registers all available tools with the MCP server.
- Currently includes:
  - Add tool (`src/tools/add.ts`)
  - DOCX Reader tool (`src/tools/docx-reader.ts`)

### 4. Transports (src/transports/)

- **streamableHttp.ts**: Handles StreamableHTTP transport for request/response communication.

## Flow of the Main Tool: DOCX Reader

The DOCX Reader tool is the primary functionality, allowing users to search for relevant sections in a DOCX document.

### Input Schema

- **user_input**: The original user text (used for language detection).
- **query**: The search query (translated keywords).

### Processing Flow

1. **Language Detection**:
   - Analyzes `user_input` for Vietnamese characters using regex.
   - Defaults to English if no Vietnamese detected.

2. **Document Loading**:
   - Reads the specified DOCX file from `src/documents/` using Node.js `fs`.
   - Converts DOCX to HTML using the Mammoth library.

3. **Section Extraction**:
   - Parses the HTML with Cheerio.
   - Extracts sections based on heading tags (h1-h6).
   - Builds hierarchical structure with levels, titles, and content, including sub-sections.

4. **Relevance Scoring**:
   - Splits `query` into words (lowercased, filtered).
   - Scores each section based on keyword matches:
     - Title matches: +3 points
     - Content matches: +1 point
     - Considers word stems (e.g., removing 's', 'ing', etc.).
   - Special handling for numeric sections: only matches main sections for pure numbers.

5. **Parent Expansion**:
   - Identifies top 5 scoring sections.
   - If a section's title matches a query word and is a whole-number section (e.g., "4."), expands to include all child sections (e.g., "4.1", "4.2").
   - Adds the parent and children to the final results with adjusted scores.

6. **Response Building**:
   - Selects top relevant sections (ensures at least 5, may exceed due to expansion).
   - Includes relationships: parent titles and neighbor titles.
   - Formats response with language guidance (e.g., "Respond in Vietnamese").
   - Returns both text content and structured `relevantSections`.

### Output Schema

- **relevantSections**: Array of objects containing:
  - `title`: Section title
  - `content`: Section content
  - `embedding`: Placeholder for future embedding
  - `parent`: Optional parent section title
  - `neighbors`: Array of neighboring section titles

This architecture ensures efficient, modular, and scalable document processing for AI agents, with features like hierarchical expansion, language detection, and relevance scoring to provide contextually relevant information.